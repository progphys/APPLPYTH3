Данный репозиторий содержит сервис для создания коротких ссылок, реализованный с помощью FastAPI. Сервис предоставляет возможности регистрации и аутентификации пользователей, создания, получения, обновления, удаления ссылок, а также получения статистики и работы с истёкшими ссылками.

## Описание API

### Аутентификация и Регистрация

- **POST `/auth/jwt/login`**  
  *Описание:* Аутентификация пользователя с помощью JWT.  
  *Тело запроса:* `application/x-www-form-urlencoded` с полями:
  - `username` (обязательное)
  - `password` (обязательное)
  - `grant_type` (опционально, должен быть равен `password`)
  - `scope` (по умолчанию пустая строка)
  - `client_id` и `client_secret` (опционально)  
  *Ответ (200):* Объект `BearerResponse` с полями:
  - `access_token` – JWT токен
  - `token_type` – тип токена (обычно `bearer`)

- **POST `/auth/jwt/logout`**  
  *Описание:* Выход пользователя.  
  *Требует:* Заголовок `Authorization` с валидным JWT токеном.  
  *Ответ (200):* Подтверждение успешного выхода.

- **POST `/auth/register`**  
  *Описание:* Регистрация нового пользователя.  
  *Тело запроса:* `application/json` с полями:
  - `email` – электронная почта (обязательное)
  - `password` – пароль (обязательное)
  - `is_active`, `is_superuser`, `is_verified` – опционально  
  *Ответ (201):* Объект `UserRead` с информацией о зарегистрированном пользователе.

### Управление ссылками

- **POST `/links/shorten`**  
  *Описание:* Создание короткой ссылки из длинной.  
  *Тело запроса:* `application/json` с полями:
  - `long_link` – исходная длинная ссылка (обязательное)
  - `custom_alias` – пользовательский алиас для короткой ссылки (опционально)
  - `expires_at` – дата и время истечения срока действия (опционально, в формате ISO 8601)  
  *Ответ (200):* Объект `LinkResponse`, содержащий:
  - `id` – идентификатор ссылки
  - `long_link` – исходная ссылка
  - `short_link` – сгенерированная короткая ссылка
  - `auth` – требуется ли аутентификация
  - `user_id` – идентификатор пользователя (если применимо)
  - `start_date`, `last_date` – даты создания и последнего обновления
  - `num` – счётчик переходов
  - `expires_at` – время истечения ссылки

- **GET `/links/`**  
  *Описание:* Получение исходной длинной ссылки по короткой.  
  *Параметры запроса:* 
  - `short_link` – короткая ссылка (обязательный параметр)  
  *Ответ (200):* JSON объект с информацией о длинной ссылке.

- **GET `/links/{short_code}/stats`**  
  *Описание:* Получение статистики по конкретной короткой ссылке.  
  *Параметры пути:* 
  - `short_code` – код короткой ссылки  
  *Ответ (200):* Объект `LinkStats`, содержащий:
  - `long_link` – исходная ссылка
  - `created_at` – дата создания
  - `clicks_count` – количество кликов
  - `last_used` – время последнего использования

- **GET `/links/search`**  
  *Описание:* Поиск короткой ссылки по длинной.  
  *Параметры запроса:*
  - `long_link` – длинная ссылка для поиска  
  *Ответ (200):* JSON объект с найденной информацией (схема не описана детально).

- **PUT `/links/{short_code}`**  
  *Описание:* Обновление существующей ссылки (смена длинной ссылки).  
  *Параметры пути:*
  - `short_code` – код короткой ссылки  
  *Тело запроса:* `application/json` с полем:
  - `new_long_link` – новая длинная ссылка  
  *Ответ (200):* Обновлённый объект `LinkResponse`.

- **DELETE `/links/{short_code}`**  
  *Описание:* Удаление короткой ссылки.  
  *Параметры пути:*
  - `short_code` – код короткой ссылки  
  *Ответ (200):* Подтверждение успешного удаления.

- **GET `/links/links/expired`**  
  *Описание:* Получение списка истёкших ссылок.  
  *Ответ (200):* Массив объектов `LinkResponse`.

### Схемы данных

- **BearerResponse** – структура ответа при аутентификации.
- **LinkCreateRequest** – структура запроса для создания ссылки.
- **LinkResponse** – структура ответа, содержащая детали ссылки.
- **LinkStats** – структура статистики ссылки.
- **UserCreate** и **UserRead** – структуры для регистрации и отображения данных пользователя.
- **ErrorModel** и **HTTPValidationError** – структуры для обработки ошибок и валидации.

## Примеры запросов

### 1. Регистрация нового пользователя

```bash
curl -X POST "http://localhost:8000/auth/register" \
     -H "Content-Type: application/json" \
     -d '{
           "email": "user@example.com",
           "password": "your_password"
         }'
```

### 2. Аутентификация (получение JWT токена)

```bash
curl -X POST "http://localhost:8000/auth/jwt/login" \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -d "username=user@example.com&password=your_password"
```

### 3. Создание короткой ссылки

```bash
curl -X POST "http://localhost:8000/links/shorten" \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer <your_access_token>" \
     -d '{
           "long_link": "https://www.example.com/some/very/long/url",
           "custom_alias": "example",
           "expires_at": "2025-12-31T23:59:59Z"
         }'
```

### 4. Получение исходной ссылки по короткой

```bash
curl -X GET "http://localhost:8000/links/?short_link=example"
```

### 5. Получение статистики по ссылке

```bash
curl -X GET "http://localhost:8000/links/example/stats"
```

### 6. Обновление ссылки

```bash
curl -X PUT "http://localhost:8000/links/example" \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer <your_access_token>" \
     -d '{
           "new_long_link": "https://www.example.com/updated/url"
         }'
```

### 7. Удаление ссылки

```bash
curl -X DELETE "http://localhost:8000/links/example" \
     -H "Authorization: Bearer <your_access_token>"
```

### 8. Получение списка истёкших ссылок

```bash
curl -X GET "http://localhost:8000/links/links/expired"
```

# Описание базы данных

В данной миграции Alembic создаются две таблицы: **user** и **links**. Ниже приведено подробное описание структуры каждой из таблиц.

## Таблица **user**

Эта таблица хранит данные пользователей системы.

- **id**: $$UUID$$  
  Уникальный идентификатор пользователя. Не допускает значение $$NULL$$ и является первичным ключом.

- **email**: $$String$$  
  Электронная почта пользователя. Обязательное поле.

- **hashed_password**: $$String$$  
  Захешированный пароль пользователя. Обязательное поле.

- **registered_at**: $$TIMESTAMP$$  
  Дата и время регистрации пользователя. Значение может быть $$NULL$$.

- **is_active**: $$Boolean$$  
  Флаг, указывающий, активен ли пользователь. Обязательное поле.

- **is_superuser**: $$Boolean$$  
  Флаг, указывающий, обладает ли пользователь правами администратора. Обязательное поле.

- **is_verified**: $$Boolean$$  
  Флаг, подтверждена ли учетная запись пользователя. Обязательное поле.

Также создается индекс на поле **id** для оптимизации запросов, хотя само поле уже является первичным ключом.

## Таблица **links**

Эта таблица отвечает за хранение информации о коротких ссылках.

- **id**: $$Integer$$  
  Уникальный идентификатор ссылки. Не допускает значение $$NULL$$ и является первичным ключом.

- **long_link**: $$String$$  
  Исходная длинная ссылка, которая сокращается. Поле допускает значение $$NULL$$.

- **short_link**: $$String$$  
  Сокращённая версия ссылки. Поле допускает значение $$NULL$$.

- **auth**: $$Boolean$$  
  Флаг, указывающий, требуется ли аутентификация для доступа к ссылке. Поле допускает значение $$NULL$$.

- **user_id**: $$UUID$$  
  Идентификатор пользователя, создавшего ссылку. Поле может быть $$NULL$$, что подразумевает отсутствие привязки к конкретному пользователю.

- **start_date**: $$DateTime$$ с временной зоной  
  Дата и время создания ссылки. Поле допускает значение $$NULL$$.

- **last_date**: $$DateTime$$ с временной зоной  
  Дата и время последнего обновления или использования ссылки. Поле допускает значение $$NULL$$.

- **num**: $$Integer$$  
  Счетчик переходов по ссылке. Поле допускает значение $$NULL$$.

- **expires_at**: $$DateTime$$ с временной зоной  
  Дата и время, когда ссылка станет недействительной. Поле допускает значение $$NULL$$.

# Запуск

Необходимо выполонить команду 

`docker-compose up -d`

# Тесты
Все тесты хранятся в репозитории, также, как и папка с покрытиями кода, плоховато получилось разобраться, как в ассинхронном случае посутпать, написал как понимал, но искренне не нравится результат.
Запуск тестов производится путем
`PYTHONPATH=src DB_USER=test DB_PASS=test DB_NAME=test_db DB_HOST=localhost DB_PORT=5432 CELERY_TASK_ALWAYS_EAGER=true python -m pytest --cov=src tests`

Также необходимо поднять локальную БД Postgres, котоаря будет тестовой БД
`docker run --name test-postgres   -e POSTGRES_USER=test   -e POSTGRES_PASSWORD=test   -e POSTGRES_DB=test_db   -p 5432:5432   -d postgres:latest`
